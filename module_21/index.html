<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker & Containerization - Module 21</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            line-height: 1.6;
            color: #222;
            background-color: #f9f9f9;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
            padding: 20px;
        }
        
        header {
            grid-column: 1 / -1;
            background-color: #fff;
            border-bottom: 1px solid #a2a9b1;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        header h1 {
            font-size: 2em;
            font-weight: normal;
            border-bottom: 1px solid #a2a9b1;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #54595d;
            font-size: 0.9em;
        }
        
        nav {
            background-color: #f8f9fa;
            border: 1px solid #a2a9b1;
            padding: 15px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        nav h2 {
            font-size: 1em;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #a2a9b1;
        }
        
        nav ul {
            list-style: none;
        }
        
        nav ul li {
            margin: 8px 0;
        }
        
        nav ul li a {
            color: #0645ad;
            text-decoration: none;
            font-size: 0.9em;
        }
        
        nav ul li a:hover {
            text-decoration: underline;
        }
        
        nav ul ul {
            margin-left: 15px;
        }
        
        main {
            background-color: #fff;
            border: 1px solid #a2a9b1;
            padding: 30px;
        }
        
        h2 {
            font-size: 1.6em;
            font-weight: normal;
            border-bottom: 1px solid #a2a9b1;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 5px;
        }
        
        h3 {
            font-size: 1.3em;
            font-weight: normal;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        h4 {
            font-size: 1.1em;
            font-weight: bold;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        
        p {
            margin-bottom: 15px;
        }
        
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border: 1px solid #a2a9b1;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        pre {
            background-color: #f8f9fa;
            border: 1px solid #a2a9b1;
            border-radius: 3px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        pre code {
            background: none;
            border: none;
            padding: 0;
        }
        
        .info-box {
            background-color: #f0f7ff;
            border-left: 4px solid #0645ad;
            padding: 15px;
            margin: 15px 0;
        }
        
        .warning-box {
            background-color: #fff9e6;
            border-left: 4px solid #fc3;
            padding: 15px;
            margin: 15px 0;
        }
        
        .command-breakdown {
            background-color: #f8f9fa;
            border: 1px solid #a2a9b1;
            padding: 15px;
            margin: 10px 0;
        }
        
        .command-breakdown h4 {
            margin-top: 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        table th,
        table td {
            border: 1px solid #a2a9b1;
            padding: 10px;
            text-align: left;
        }
        
        table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .pros, .cons {
            border: 1px solid #a2a9b1;
            padding: 15px;
            border-radius: 5px;
        }
        
        .pros {
            background-color: #f0fff0;
        }
        
        .cons {
            background-color: #fff5f5;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Docker & Containerization</h1>
            <p class="subtitle">Module 21 - Bootcamp Reference Guide</p>
        </header>
        
        <nav>
            <h2>Contents</h2>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#what-is-docker">What is Docker?</a></li>
                <li><a href="#how-it-works">How Docker Works</a></li>
                <li><a href="#docker-commands">Docker Commands</a>
                    <ul>
                        <li><a href="#essential-commands">Essential Commands</a></li>
                        <li><a href="#intermediate-commands">Intermediate Commands</a></li>
                    </ul>
                </li>
                <li><a href="#pre-made-containers">Pre-made Containers</a></li>
                <li><a href="#dockerfile">Dockerfile Deep Dive</a></li>
                <li><a href="#docker-compose">Docker Compose</a></li>
                <li><a href="#local-vs-cloud">Local vs Cloud Deployment</a></li>
                <li><a href="#pros-cons">Pros & Cons</a></li>
                <li><a href="#importance">Why It Matters</a></li>
            </ul>
        </nav>
        
        <main>
            <section id="introduction">
                <h2>Introduction to Containerization</h2>
                <p>Containerization is a lightweight form of virtualization that allows you to package an application and all of its dependencies into a standardized unit called a container. Unlike traditional virtual machines that require a full operating system, containers share the host system's kernel while maintaining isolated user spaces.</p>
                
                <p>This approach has revolutionized how we develop, ship, and deploy applications, making it easier to ensure consistency across different environments and streamline the development-to-production pipeline.</p>
            </section>
            
            <section id="what-is-docker">
                <h2>What is Docker?</h2>
                <p>Docker is a platform that enables developers to build, package, and distribute applications as lightweight containers. It's the most popular containerization platform and has become an industry standard for modern application deployment.</p>
                
                <p>Think of Docker as a shipping container system for software. Just as shipping containers standardized the transportation of goods regardless of their contents, Docker containers standardize the packaging of applications regardless of their programming language, framework, or dependencies.</p>
                
                <h3>Key Components</h3>
                <ul>
                    <li><strong>Docker Engine:</strong> The runtime that builds and runs containers</li>
                    <li><strong>Docker Image:</strong> A read-only template containing your application and dependencies</li>
                    <li><strong>Docker Container:</strong> A running instance of an image</li>
                    <li><strong>Docker Hub:</strong> A registry for storing and sharing Docker images</li>
                    <li><strong>Dockerfile:</strong> A text file with instructions to build a Docker image</li>
                </ul>
            </section>
            
            <section id="how-it-works">
                <h2>How Docker Works</h2>
                <p>Docker uses a client-server architecture. The Docker client communicates with the Docker daemon, which does the heavy lifting of building, running, and managing containers.</p>
                
                <h3>The Container Lifecycle</h3>
                <ol>
                    <li><strong>Build:</strong> Create a Docker image from a Dockerfile</li>
                    <li><strong>Ship:</strong> Push the image to a registry (like Docker Hub)</li>
                    <li><strong>Run:</strong> Pull the image and run it as a container</li>
                </ol>
                
                <div class="info-box">
                    <strong>Key Concept:</strong> Containers are ephemeral by design. They can be started, stopped, and deleted without affecting the underlying image. Data that needs to persist should be stored in volumes or bind mounts.
                </div>
            </section>
            
            <section id="docker-commands">
                <h2>Docker Commands</h2>
                <p>Understanding Docker commands is essential for working with containers. Let's break down the most important commands and what each part does.</p>
                
                <h3 id="essential-commands">Essential Commands</h3>
                
                <div class="command-breakdown">
                    <h4>docker run</h4>
                    <pre><code>docker run -d -p 3000:3000 --name myapp myapp:latest</code></pre>
                    <table>
                        <tr>
                            <th>Component</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>docker run</code></td>
                            <td>Creates and starts a new container from an image</td>
                        </tr>
                        <tr>
                            <td><code>-d</code></td>
                            <td>Detached mode - runs container in the background</td>
                        </tr>
                        <tr>
                            <td><code>-p 3000:3000</code></td>
                            <td>Port mapping - maps host port 3000 to container port 3000 (HOST:CONTAINER)</td>
                        </tr>
                        <tr>
                            <td><code>--name myapp</code></td>
                            <td>Assigns a custom name to the container for easier reference</td>
                        </tr>
                        <tr>
                            <td><code>myapp:latest</code></td>
                            <td>The image name and tag to use (IMAGE:TAG)</td>
                        </tr>
                    </table>
                </div>
                
                <div class="command-breakdown">
                    <h4>docker build</h4>
                    <pre><code>docker build -t myapp:v1.0 .</code></pre>
                    <table>
                        <tr>
                            <th>Component</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>docker build</code></td>
                            <td>Builds an image from a Dockerfile</td>
                        </tr>
                        <tr>
                            <td><code>-t myapp:v1.0</code></td>
                            <td>Tags the image with a name and version (NAME:TAG)</td>
                        </tr>
                        <tr>
                            <td><code>.</code></td>
                            <td>Build context - the directory containing the Dockerfile (current directory)</td>
                        </tr>
                    </table>
                </div>
                
                <div class="command-breakdown">
                    <h4>docker ps</h4>
                    <pre><code>docker ps -a</code></pre>
                    <table>
                        <tr>
                            <th>Component</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>docker ps</code></td>
                            <td>Lists running containers</td>
                        </tr>
                        <tr>
                            <td><code>-a</code></td>
                            <td>Shows all containers (including stopped ones)</td>
                        </tr>
                    </table>
                </div>
                
                <div class="command-breakdown">
                    <h4>docker stop / docker start</h4>
                    <pre><code>docker stop myapp
docker start myapp</code></pre>
                    <p><code>docker stop</code> gracefully stops a running container by sending SIGTERM, then SIGKILL after a grace period. <code>docker start</code> restarts a stopped container.</p>
                </div>
                
                <div class="command-breakdown">
                    <h4>docker pull</h4>
                    <pre><code>docker pull mongo:latest</code></pre>
                    <p>Downloads an image from Docker Hub (or another registry) without running it. Useful for pre-downloading images or updating to the latest version.</p>
                </div>
                
                <div class="command-breakdown">
                    <h4>docker images</h4>
                    <pre><code>docker images</code></pre>
                    <p>Lists all Docker images stored locally on your machine, showing repository name, tag, image ID, creation date, and size.</p>
                </div>
                
                <h3 id="intermediate-commands">Intermediate Commands</h3>
                
                <div class="command-breakdown">
                    <h4>docker exec</h4>
                    <pre><code>docker exec -it myapp /bin/bash</code></pre>
                    <table>
                        <tr>
                            <th>Component</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>docker exec</code></td>
                            <td>Executes a command in a running container</td>
                        </tr>
                        <tr>
                            <td><code>-it</code></td>
                            <td>Interactive terminal - combines -i (interactive) and -t (pseudo-TTY)</td>
                        </tr>
                        <tr>
                            <td><code>myapp</code></td>
                            <td>The container name or ID</td>
                        </tr>
                        <tr>
                            <td><code>/bin/bash</code></td>
                            <td>The command to execute (opens a bash shell)</td>
                        </tr>
                    </table>
                    <p class="warning-box"><strong>Note:</strong> This is incredibly useful for debugging. You can access the container's file system and run commands just like you would on a Linux machine.</p>
                </div>
                
                <div class="command-breakdown">
                    <h4>docker logs</h4>
                    <pre><code>docker logs -f --tail 100 myapp</code></pre>
                    <table>
                        <tr>
                            <th>Component</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>docker logs</code></td>
                            <td>Fetches logs from a container</td>
                        </tr>
                        <tr>
                            <td><code>-f</code></td>
                            <td>Follow mode - streams logs in real-time (like tail -f)</td>
                        </tr>
                        <tr>
                            <td><code>--tail 100</code></td>
                            <td>Shows only the last 100 lines of logs</td>
                        </tr>
                        <tr>
                            <td><code>myapp</code></td>
                            <td>The container name or ID</td>
                        </tr>
                    </table>
                </div>
                
                <div class="command-breakdown">
                    <h4>docker volume</h4>
                    <pre><code>docker volume create mydata
docker run -v mydata:/app/data myapp</code></pre>
                    <table>
                        <tr>
                            <th>Component</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>docker volume create</code></td>
                            <td>Creates a named volume for persistent data storage</td>
                        </tr>
                        <tr>
                            <td><code>-v mydata:/app/data</code></td>
                            <td>Mounts the volume - VOLUME_NAME:CONTAINER_PATH</td>
                        </tr>
                    </table>
                    <p>Volumes persist data even when containers are deleted. Essential for databases and any data you want to keep.</p>
                </div>
                
                <div class="command-breakdown">
                    <h4>docker network</h4>
                    <pre><code>docker network create mynetwork
docker run --network mynetwork myapp</code></pre>
                    <p>Creates custom networks that allow containers to communicate with each other. Containers on the same network can reference each other by container name.</p>
                </div>
                
                <div class="command-breakdown">
                    <h4>docker rm / docker rmi</h4>
                    <pre><code>docker rm myapp
docker rmi myapp:v1.0</code></pre>
                    <p><code>docker rm</code> removes stopped containers. <code>docker rmi</code> removes images. Use with caution - this deletes data permanently.</p>
                </div>
            </section>
            
            <section id="pre-made-containers">
                <h2>Pre-made Containers from Docker Hub</h2>
                <p>One of Docker's greatest strengths is Docker Hub, a public registry with thousands of pre-built images. You don't need to create everything from scratch - you have access to official images for most popular software.</p>
                
                <h3>MongoDB Container</h3>
                <p>MongoDB provides official Docker images that make it incredibly easy to spin up a database without installing MongoDB on your machine.</p>
                
                <pre><code>docker run -d \
  --name mongodb \
  -p 27017:27017 \
  -e MONGO_INITDB_ROOT_USERNAME=admin \
  -e MONGO_INITDB_ROOT_PASSWORD=password123 \
  -v mongodata:/data/db \
  mongo:latest</code></pre>
                
                <div class="info-box">
                    <strong>What's happening here?</strong>
                    <ul>
                        <li><code>-e</code> sets environment variables for MongoDB authentication</li>
                        <li><code>-v mongodata:/data/db</code> persists database data in a volume</li>
                        <li><code>mongo:latest</code> pulls the official MongoDB image</li>
                        <li>Port 27017 is MongoDB's default port</li>
                    </ul>
                </div>
                
                <h3>Node.js Container</h3>
                <p>The official Node.js images come in many variants with different Node versions and base operating systems.</p>
                
                <pre><code>docker run -d \
  --name mynode \
  -p 3000:3000 \
  -v $(pwd):/app \
  -w /app \
  node:18-alpine \
  node server.js</code></pre>
                
                <div class="info-box">
                    <strong>Image variants:</strong>
                    <ul>
                        <li><code>node:18</code> - Full Debian-based image with Node 18</li>
                        <li><code>node:18-alpine</code> - Lightweight Alpine Linux version (much smaller)</li>
                        <li><code>node:18-slim</code> - Minimal Debian version</li>
                    </ul>
                    <p>Alpine images are popular because they're smaller (around 50MB vs 300MB+), which means faster downloads and less storage space.</p>
                </div>
                
                <h3>Using Pre-made Images in Your Workflow</h3>
                <p>These images are maintained by the software vendors themselves or trusted community members. You can:</p>
                <ul>
                    <li>Use them directly in development (like the MongoDB example)</li>
                    <li>Use them as base images in your Dockerfile (we'll see this next)</li>
                    <li>Extend them with your own customizations</li>
                </ul>
                
                <p>Search Docker Hub at <code>hub.docker.com</code> to find images for Redis, PostgreSQL, Nginx, and thousands of other tools.</p>
            </section>
            
            <section id="dockerfile">
                <h2>Dockerfile Deep Dive</h2>
                <p>A Dockerfile is a text document containing instructions for building a Docker image. It's like a recipe that tells Docker exactly how to set up your application environment.</p>
                
                <h3>Example: Node.js Application Dockerfile</h3>
                <pre><code># Use official Node.js runtime as base image
FROM node:18-alpine

# Set working directory inside the container
WORKDIR /app

# Copy package files first (for better caching)
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy application source code
COPY . .

# Expose the port the app runs on
EXPOSE 3000

# Define environment variable
ENV NODE_ENV=production

# Command to run the application
CMD ["node", "server.js"]</code></pre>
                
                <h3>Dockerfile Instructions Explained</h3>
                
                <h4>FROM</h4>
                <p><code>FROM node:18-alpine</code> specifies the base image. Every Dockerfile must start with FROM. This determines what's already installed in your container. Here, we're starting with a lightweight Node.js 18 environment on Alpine Linux.</p>
                
                <h4>WORKDIR</h4>
                <p><code>WORKDIR /app</code> sets the working directory for subsequent instructions. All file paths will be relative to this directory. If the directory doesn't exist, Docker creates it.</p>
                
                <h4>COPY</h4>
                <p><code>COPY package*.json ./</code> copies files from your host machine into the container. The wildcard matches both package.json and package-lock.json. We copy these separately first for better caching.</p>
                
                <div class="info-box">
                    <strong>Layer Caching:</strong> Docker caches each instruction as a layer. By copying package files separately, Docker can reuse the cached layer with installed dependencies if package.json hasn't changed, even if your source code has. This makes rebuilds much faster.
                </div>
                
                <h4>RUN</h4>
                <p><code>RUN npm ci --only=production</code> executes commands during the build process. Each RUN instruction creates a new layer. <code>npm ci</code> is preferred over <code>npm install</code> for production because it's faster and more reliable.</p>
                
                <h4>EXPOSE</h4>
                <p><code>EXPOSE 3000</code> documents which port the container listens on. This is metadata - it doesn't actually publish the port (you still need <code>-p</code> in docker run). Think of it as documentation for users of your image.</p>
                
                <h4>ENV</h4>
                <p><code>ENV NODE_ENV=production</code> sets environment variables. These are available when the container runs and can affect how your application behaves.</p>
                
                <h4>CMD</h4>
                <p><code>CMD ["node", "server.js"]</code> specifies the default command to run when the container starts. This can be overridden when running the container. Use the JSON array format (exec form) for better signal handling.</p>
                
                <h3>Additional Important Instructions</h3>
                
                <h4>ENTRYPOINT</h4>
                <p>Similar to CMD but cannot be easily overridden. Often used with CMD to create flexible container commands:</p>
                <pre><code>ENTRYPOINT ["node"]
CMD ["server.js"]</code></pre>
                
                <h4>ARG</h4>
                <p>Defines build-time variables that can be passed when building the image:</p>
                <pre><code>ARG NODE_VERSION=18
FROM node:${NODE_VERSION}-alpine</code></pre>
                
                <h4>Multi-stage Builds</h4>
                <p>For more complex applications, you can use multiple FROM statements to create smaller final images:</p>
                <pre><code># Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY package*.json ./
RUN npm ci --only=production
CMD ["node", "dist/server.js"]</code></pre>
            </section>
            
            <section id="docker-compose">
                <h2>Docker Compose</h2>
                <p>Docker Compose is a tool for defining and running multi-container Docker applications. Instead of running multiple docker run commands with complex flags, you define everything in a YAML file.</p>
                
                <h3>Why Docker Compose?</h3>
                <p>Modern applications rarely run in isolation. A typical full-stack app needs:</p>
                <ul>
                    <li>A Node.js application server</li>
                    <li>A MongoDB database</li>
                    <li>Maybe Redis for caching</li>
                    <li>Maybe Nginx as a reverse proxy</li>
                </ul>
                <p>Managing all these containers manually becomes tedious. Docker Compose solves this by letting you define all services in one file and manage them with simple commands.</p>
                
                <h3>Example: Node.js + MongoDB Application</h3>
                <pre><code>version: '3.8'

services:
  # MongoDB Database Service
  mongodb:
    image: mongo:latest
    container_name: my_mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: securepassword123
      MONGO_INITDB_DATABASE: myapp
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
      - ./mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro
    networks:
      - app-network

  # Node.js Application Service
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: my_node_app
    restart: unless-stopped
    environment:
      NODE_ENV: production
      MONGODB_URI: mongodb://admin:securepassword123@mongodb:27017/myapp?authSource=admin
      PORT: 3000
    ports:
      - "3000:3000"
    volumes:
      - ./src:/app/src
      - /app/node_modules
    depends_on:
      - mongodb
    networks:
      - app-network

# Define named volumes
volumes:
  mongodb_data:
    driver: local

# Define custom network
networks:
  app-network:
    driver: bridge</code></pre>
                
                <h3>Docker Compose File Breakdown</h3>
                
                <h4>version</h4>
                <p>Specifies the Docker Compose file format version. Version 3.8 is modern and widely supported.</p>
                
                <h4>services</h4>
                <p>Each service is a container. Here we have two services: mongodb and app. Services can reference each other by name.</p>
                
                <h4>image vs build</h4>
                <p>For MongoDB, we use <code>image: mongo:latest</code> to pull a pre-made image. For our app, we use <code>build:</code> to build from our Dockerfile.</p>
                
                <h4>container_name</h4>
                <p>Assigns a specific name to the container. Without this, Docker Compose generates names based on the project directory.</p>
                
                <h4>restart</h4>
                <p><code>unless-stopped</code> means the container will automatically restart if it crashes, but not if you manually stop it. Other options include <code>always</code> and <code>no</code>.</p>
                
                <h4>environment</h4>
                <p>Sets environment variables. Notice in the app service, we use <code>mongodb://mongodb:27017</code> - we can reference the MongoDB service by its service name because they're on the same network.</p>
                
                <div class="info-box">
                    <strong>Container Networking Magic:</strong> When services are in the same Docker Compose network, they can communicate using service names as hostnames. So <code>mongodb</code> in the connection string automatically resolves to the MongoDB container's IP address. This is one of Docker Compose's most powerful features.
                </div>
                
                <h4>ports</h4>
                <p>Maps host ports to container ports, just like <code>-p</code> in docker run. Format is <code>"HOST:CONTAINER"</code>.</p>
                
                <h4>volumes</h4>
                <p>Two types here:</p>
                <ul>
                    <li>Named volumes: <code>mongodb_data:/data/db</code> - managed by Docker, persists data</li>
                    <li>Bind mounts: <code>./src:/app/src</code> - links a host directory to container directory, useful for development</li>
                </ul>
                <p>The <code>/app/node_modules</code> volume is an anonymous volume that prevents the host's (potentially empty) node_modules from overriding the container's installed dependencies.</p>
                
                <h4>depends_on</h4>
                <p>Defines startup order. The app service won't start until mongodb is running. However, this doesn't